# Using Asyncio in Python

[책 링크](https://product.kyobobook.co.kr/detail/S000001810381)

![image](https://github.com/junah201/self-study/assets/75025529/c79baf3b-51f3-43cb-b3de-74320b137ca0)

### 목적

파이썬에서 비동기에 대해서 디테일하게 모르고 넘어갔던 부분에 대해서 학습하기

### 학습 상태

- [x] CHAPTER 1 Asyncio 소개
- [x] CHAPTER 2 스레드에 관한 진실
- [ ] CHAPTER 3 Asyncio 공략
- [ ] CHAPTER 4 여러분이 사용하지 않는 Asyncio 라이브러리 20개
- [ ] CHAPTER 5 마치며
- [ ] APPENDIX A 파이썬의 비동기 지원에 대한 역사
- [ ] APPENDIX B 보충 자료

### 학습 메모

학습 도중 새롭게 알게된 사실에 대해서 메모합니다.

**CHAPTER 1 Asyncio 소개**

- CPU는 작업을 완료한 후 네트워크 I/O 작업을 기다린다. CPU 작업은 네트워크 작업보다 10만 배 이상 빠르다.
- I/O 위주 작업에 스레드 기반 병행 처리보다 비동기 기반 병행처리를 적용해야 하는 이유
  - Asyncio는 스레드를 사용하는 선점형 멀티태스킹보다 오류, 경합조건, 혹은 비결정론적 위험 요소(nondeterministic danger)에 더욱 안전하다.
  - Asyncio를 통해 **동시에** 수천 개의 소켓 연결(WebSocket, MQTT)을 간단히 처리할 수 있다.
- Asyncio를 통해 GIL를 해결할 수 있는 것이 아니라, GIL의 문제는 멀티스레드를 사용할 때 멀티코어 병렬화를 막는 것이지만, Asyncio는 명목상 단일 스레드이기 때문에 GIL의 영향을 받지 않는 것이다.

**CHAPTER 2 스레드에 관한 진실**

- 스레딩의 장점
  - 읽기 쉬운 코드 (코드가 top-down 방식이며, 함수 내에서 다른 코드 혹은 함수의 동시 실행에 대해 고려할 필요가 없다.)
  - 공유 메모리를 통한 병렬처리 (스레드 간 공유 메모리를 통해 통신하면서 코드에서 여러 CPU를 이용할 수 있다.)
    - 하지만 파이썬에서는 GIL로 인해서 병렬성이 제한됨
  - 많은 모범 사례 및 노하우

- 스레딩의 단점
  - 스레딩은 어렵다. (스레드 관련 오류나 경합 조건은 가장 고치기 어렵다.)
  - 스레드는 더 많은 OS 자원을 사용한다.
  - 스레딩은 처리량에 영향을 줄 수 있다. (매우 높은 병행 수준(5000개 이상의 스레드)에서는 콘텍스트 전환 비용으로 인해 처리량에 영향이 있을 수 있다.)
  - 스레딩은 유연하지 않다. (ex, 일부 스레드는 소켓으로부터 데이터가 도달하기를 기다리고 있을 수도 있다. 하지만 OS 스케줄러는 데이터가 도달하여 해당 스레드의 실행 재개가 필요하기 전까지 수천 번에 거처 콘텍스트 전환을 의밓 없이 수행할 것이다.)

- 경합 조건 오류의 예시
  - 스레딩 연산에서 `+=` 연산에 경우 내부적으로 여러 단계로 구성되어 있다.
    1. 원래 변수 값을 읽어 임시 저장소에 저장한다.
    2. 임시 저장소 내의 값에 더할 값을 더한다.
    3. 원래 변수의 값에 임시 저장소 내의 값을 복제하여 저장한다.
  - 내부적으로 `+=`이 진행되는 중간에 스레드 간 콘텍스트 전환이 발생하면, 임시 저장소에 저장된 값이 유실되는 경합 조건 오류가 발생할 수 있다.
  - 이러한 경합 조건 오류는 소스 코드만 확인해서는 찾아내기 매우 힘들다. (OS는 거의 모든 곳에서 스레드 간의 콘텍스트 전환을 수행할 수 있다.)
